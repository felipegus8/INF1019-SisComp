Felipe Viberti - 1510384

Questão 1)Faça um programa para somar matrizes de acordo com o seguinte algoritmo
O primeiro processo irá criar duas matrizes preenchidas e uma terceira vazia em 3 áreas de memória compartilhada.O seu programa deverá gerar um processo para o cálculo de cada linha da matriz solução.O processo pai deve imprimir a matriz solução.
-----------------------------------------------------

Arquivo .c:
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>

int main () {

	int segmento1, segmento2, segmento3, segmento1_aux, segmento2_aux, segmento3_aux, id_filho;
	int **matriz1, **matriz2, **matriz3;
	int i, j;

 //Attach da matriz em si.
	segmento1 = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
	matriz1 = (int **) shmat (segmento1, 0, 0);

 //Attach de cada posição da matriz.
	for(i=0;i<9;i++) {
		segmento1_aux = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
		matriz1[i] = (int *) shmat (segmento1_aux, 0, 0);
	}

   //Attach da matriz em si.
	segmento2 = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
	matriz2 = (int **) shmat (segmento2, 0, 0);

  //Attach de cada posição da matriz.
	for(i=0;i<9;i++) {
		segmento2_aux = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
		matriz2[i] = (int *) shmat (segmento2_aux, 0, 0);
	}
  //Attach da matriz em si.
	segmento3 = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
	matriz3 = (int **) shmat (segmento3, 0, 0);

  //Attach de cada posição da matriz.
	for(i=0;i<9;i++) {
		segmento3_aux = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
		matriz3[i] = (int *) shmat (segmento3_aux, 0, 0);
	}

  //Preenchendo a primeira matriz com o valor 8 em cada posição.
	for(i=0;i<3;i++) {
		for(j=0; j<3; j++) {
			matriz1[i][j] = 8;
		}
	}
 //Preenchendo a segunda matriz com o valor 88 em cada posição.
	for(i=0;i<3;i++) {
		for(j=0; j<3; j++) {
			matriz2[i][j] = 88;
		}
	}

 //Fazendo um fork para cada linha da matriz e preenchendo a matriz resultado dentro de cada linha.
	for(i=0;i<3;i++) {
		if ((id_filho = fork()) < 0) {
			puts("Erro na criação do novo processo");
			exit(1);
		}
		else if (id_filho==0) {
			for(j=0;j<3;j++) {
				matriz3[i][j] = matriz1[i][j] + matriz2[i][j];
			}
			shmdt(matriz1);
			shmdt(matriz2);
			shmdt(matriz3);
			exit(1);
		}
		else {
			wait(0);
		}
	}

  //Print na matriz.
	for(i=0;i<3;i++) {
		for(j=0;j<3;j++) {
			printf("%d\t", matriz3[i][j]);
		}
		printf("\n");
	}

  //Detach de cada posição de cada matriz.
	for(i=0;i<3;i++) {
		shmdt(matriz1[i]);
		shmdt(matriz2[i]);
		shmdt(matriz3[i]);
	}
	//Detach dos segmentos auxiliares.
	shmctl(segmento1_aux, IPC_RMID, 0);
	shmctl(segmento2_aux, IPC_RMID, 0);
	shmctl(segmento3_aux, IPC_RMID, 0);

//Detach da matriz em si
	shmdt(matriz1);
	shmdt(matriz2);
	shmdt(matriz3);
	shmctl(segmento1, IPC_RMID, 0);
	shmctl(segmento2, IPC_RMID, 0);
	shmctl(segmento2, IPC_RMID, 0);
	return 0;
}

-----------------------------------------------------

Auxiliar.Txt:
Não houve arquivo auxiliar nessa questão.

-----------------------------------------------------

Compilação e Execucação:
$ gcc -Wall -o ex1 lab3_1.c
$./ex1

-----------------------------------------------------

Resultado:
96	96	96	
96	96	96	
96	96	96

-----------------------------------------------------

Conclusão:
No início o primeiro processo faz o attach de todas as matrizes e de cada uma das suas posições. Depois, as 2 primeiras matrizes são preenchidas e para cada linha da matriz eu faço um fork para calcular a soma da própria e preencher cada linha da matriz resultante por vez.Por fim eu dou print na matriz resultante e faço e deattach de cada posição da matriz e da matriz em si. 


-----------------------------------------------------

Questão 2) Faça um programa que: Leia a mensagem do dia do teclado Crie uma memória compartilhada com a chave 8180 Salve a mensagem na memória Faça um outro programa que utilize a mesma chave (8180) e exiba a mensagem do dia para o usuário.

-----------------------------------------------------

Arquivo .c:
Lab 3_2_1.c:

#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main () {

	int segmento;
	char *msgDoDia;

	segmento = shmget (8180, sizeof(char) * 120, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
	if(segmento == -1) {
		printf("erro");
		exit(1);
	}

	msgDoDia = (char *) shmat (segmento, 0, 0);
	printf("Digite a mensagem do dia:\n");
        scanf("%[^\n]", msgDoDia);
	printf("pai: %s \n", msgDoDia);
	shmdt(msgDoDia);
	return 0;
}


Lab3_2_2.c:
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main () {

	char *msgDoDia;
	int segmento;

	segmento = shmget (8180, sizeof(char) * 120, S_IRUSR | S_IWUSR);
	if(segmento == -1) {
		printf("erro");
		exit(1);
	}
	msgDoDia = (char *) shmat (segmento, 0, 0);

	printf("A mensagem do dia é: %s \n", msgDoDia);

	shmdt(msgDoDia);
	shmctl(segmento, IPC_RMID, 0);
	return 0;
}


-----------------------------------------------------

Auxiliar .txt:
Não houve arquivo auxiliar nessa questão.

-----------------------------------------------------

Compilação e Execução:
$gcc -Wall -o ex2_1 lab3_2_1.c
$./ex2_1
$gcc -Wall -o ex2_2 lab3_2_2.c
$./ex2_2

-----------------------------------------------------

Resultado:
Execução do Programa 1 :
Digite a mensagem do dia:
Hello World
pai: Hello World 

Execução do Programa 2:
A mensagem do dia é: Hello World 
-----------------------------------------------------

Conclusão:
No primeiro programa eu dou um attach em uma área de memória de 120 bytes(já que não foi especificado o tamanho) e depois preencho aquela área de memória com a mensagem que foi digitada pelo usuário no teclado.Como eu não faço um não dou um deattach naquela posição no final do programa, a mensagem continua lá.No segundo programa eu acesso essa área de memória compartilhada e imprimo no console a mensagem que está lá.Tudo isso serve para mostrar que o calculo da matriz resultante fica mais rápido quando se usa memória compartilhada.

-----------------------------------------------------

Questão 3)Faça um programa paralelo para achar a transposta de uma matriz.Crie uma matriz na memória compartilhada e leia dados do teclado para preencher a matriz (4x4)Crie outra matriz para armazenar a matriz transposta. Gere 4 processos para calcular a transposta onde cada processo deve transpor uma linha para a respectiva coluna da matriz transposta.O processo pai deve imprimir a matriz original e a transposta.
-----------------------------------------------------

Arquivo .c:
#include <stdio.h>
#include <stdlib.h>
#include <sys/shm.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>

void imprimirMatriz(int * mat);

int main () {
    int i, j, segmento1, segmento2, id, status, val,segmento1_aux,segmento2_aux;
    int  **mat,**mat2;

    // Aloca a memória compartilhada
    segmento1 = shmget(IPC_PRIVATE, 16 * sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR |  S_IWUSR);f
    mat = (int **) shmat (segmento1, 0, 0);
    
    //Attach de cada posição da matriz.
    for(i=0;i<16;i++) {
        segmento1_aux = shmget (IPC_PRIVATE, sizeof(int) * 16, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
        mat[i] = (int *) shmat (segmento1_aux, 0, 0);
    }
    segmento2 = shmget(IPC_PRIVATE, 16 * sizeof(int), IPC_CREAT | IPC_EXCL | S_IRUSR |  S_IWUSR);
    mat2 = (int **) shmat (segmento2, 0, 0);

    for(i=0;i<9;i++) {
        segmento2_aux = shmget (IPC_PRIVATE, sizeof(int) * 9, IPC_CREAT | IPC_EXCL |S_IRUSR | S_IWUSR);
       mat2[i] = (int *) shmat (segmento2_aux, 0, 0);
    }
    
    printf("Entre com os numeros da matriz:\n");
    for (i = 0; i < 4; i++) {
      printf("Linha %d: ", i + 1);
      for (j=0;j<4;j++) {
        scanf(" %d", &val);
        mat[i][j] = val;
      }
    }

    if ((id = fork()) < 0) { // Processo pai
            puts ("Erro na criação do novo processo");
            exit (-2);
    }
    else if (id == 0) { // Processo filho 1
            for (i = 0; i < 4; i++) {
                mat2[i][0] = mat[0][i];
            }

            id = fork();

            if (id == 0) { // Processo filho 2
                for (i = 0; i < 4; i++) {
                  mat2[i][1] = mat[1][i];
                }

                id = fork();

                if (id == 0) { // Processo filho 3
                    for (i = 0; i < 4; i++) {
                    mat2[i][2] = mat[2][i];
                    }

                    id = fork();

                    if (id == 0) { // Processo filho 4
                        for (i = 0; i < 4; i++) {
                            mat2[i][3] = mat[3][i];
                        }
                    }
                }
            }
    }
    else { // Processo pai
        sleep(1);
        waitpid(-1, &status, 0);
        printf ("\nMatriz:\n");
        for(i=0;i<4;i++) {
          printf("%d\t%d\t%d\t%d\n",mat[i][0],mat[i][1],mat[i][2],mat[i][3]);
        }
        printf ("Transposta:\n");
        for(i=0;i<4;i++) {
          printf("%d\t%d\t%d\t%d\n",mat2[i][0],mat2[i][1],mat2[i][2],mat2[i][3]);
        }
    }

    for(i=0;i<4;i++) {
        shmdt(mat[i]);
        shmdt(mat2[i]);
    }
    shmctl(segmento1_aux, IPC_RMID, 0);
    shmctl(segmento2_aux, IPC_RMID, 0);
    
    // Libera a memória compartilhada das matrizes
    shmdt (mat);
    shmdt (mat2);

    // Libera a memória compartilhada
    shmctl (segmento1, IPC_RMID, 0);
    shmctl (segmento2, IPC_RMID, 0);

    return 0;
}



-----------------------------------------------------

Auxiliar .txt:
Não houve arquivo auxiliar nessa questão.

-----------------------------------------------------

Compilação e Execução:
$gcc -Wall -o ex3 lab1_3.c
$./ex3

-----------------------------------------------------

Resultado:
Entre com os números da matriz:
Linha 1: 1 2 3 4
Linha 2: 1 1 1 1
Linha 3: 2 3 4 5
Linha 4: 8 9 10 11

Matriz:
1	2	3	4
1	1	1	1
2	3	4	5
8	9	10	11
Transposta:
1	1	2	8
2	1	3	9
3	1	4	10
4	1	5	11


-----------------------------------------------------

Conclusão:
O processo aqui é semelhante ao exercício 1.No inicio eu dou attach das 2 matrizes e de cada uma das suas posições.Depois eu preencho a primeira matriz com os dados do teclado e faço 4 forks para criar 4 processos.Cada processo preenche uma linha da matriz transposta.No pai eu imprimo a matriz recebida e sua matriz transposta e  no final do programa eu faço e deattach de cada posição da matriz e da matriz em si. 
