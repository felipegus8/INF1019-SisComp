Felipe Viberti - 1510384

Questão 1)Compile e Execute os códigos apresentados nos slides anteriores. Explicando os códigos e as diferenças entre FIFO com leitura/ escrita bloqueante e não bloqueante. No seu relatório inclua os código de leitura e escrita bloqueante e não bloqueante. E as respectivas explicações dos códigos e diferenças.
-----------------------------------------------------

Arquivos .c:
Leitura não bloqueante:

#include <stdio.h>
#include <sys/shm.h>
#include <signal.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>

#define OPENMODE (O_RDONLY | O_NONBLOCK)
#define FIFO "minhaFifo"
int main (void)
{
   int fpFIFO;
   char ch;
   if (access(FIFO, F_OK) == -1)
   {
                  if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
                  {
                            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
                            return -1;
}
   }
   puts ("Abrindo FIFO");
   if ((fpFIFO = open (FIFO, OPENMODE)) < 0)
   {
                  fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
                  return -2;
   }
   puts ("Começando a ler...");
   while (read (fpFIFO, &ch, sizeof(ch)) > 0)
                  putchar (ch);
   puts ("Fim da leitura");
   close (fpFIFO);
return 0; 
}


Escrita não bloqueante:

#include <stdio.h>
#include <sys/shm.h>
#include <signal.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#include <string.h>
 #define OPENMODE (O_WRONLY | O_NONBLOCK)
 #define FIFO "minhaFifo"
 int main (void)
 {
    int fpFIFO;
    char mensagem[] = "Melancia sem caroço";
    if (access(FIFO, F_OK) == -1)
    {
                   if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
                   {
                            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
                            return -1;
}
    }
    puts ("Abrindo FIFO");
    if ((fpFIFO = open (FIFO, OPENMODE)) < 0)
    {
                   fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
                   return -2;
    }
    puts ("Começando a escrever...");
    write(fpFIFO, mensagem, strlen(mensagem));
    puts ("Fim da escrita");
    close (fpFIFO);
    return 0;
   }


Leitura bloqueante:


#include <stdio.h>
#include <sys/shm.h>
#include <signal.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>

#define OPENMODE (O_RDONLY)
#define FIFO "minhaFifo"
int main (void)
{
   int fpFIFO;
   char ch;
   if (access(FIFO, F_OK) == -1)
   {
                  if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
                  {
                            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
                            return -1;
}
   }
   puts ("Abrindo FIFO");
   if ((fpFIFO = open (FIFO, OPENMODE)) < 0)
   {
                  fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
                  return -2;
   }
   puts ("Começando a ler...");
   while (read (fpFIFO, &ch, sizeof(ch)) > 0)
                  putchar (ch);
   puts ("Fim da leitura");
   close (fpFIFO);
return 0; 
}


Escrita bloqueante:


#include <stdio.h>
#include <sys/shm.h>
#include <signal.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/wait.h>
#include <stdlib.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <sys/types.h>
#include <string.h>
 #define OPENMODE (O_WRONLY)
 #define FIFO "minhaFifo"
 int main (void)
 {
    int fpFIFO;
    char mensagem[] = "Melancia sem caroço";
    if (access(FIFO, F_OK) == -1)
    {
                   if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0)
                   {
                            fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
                            return -1;
}
    }
    puts ("Abrindo FIFO");
    if ((fpFIFO = open (FIFO, OPENMODE)) < 0)
    {
                   fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
                   return -2;
    }
    puts ("Começando a escrever...");
    write(fpFIFO, mensagem, strlen(mensagem));
    puts ("Fim da escrita");
    close (fpFIFO);
    return 0;
  }

-----------------------------------------------------

Auxiliar.Txt:
Não houve arquivo auxiliar nessa questão.

-----------------------------------------------------

Compilação e Execucação:
$ gcc -Wall -o ReadFifoNonBlocking ex1_1.c
$ ./ReadFifoNonBlocking
$ gcc -Wall -o WriteFifoNonBlocking ex1_2.c
$ ./WriteFifoNonBlocking
$ gcc -Wall -o ReadFifoBlocking ex1_3.c
$ gcc -Wall -o WriteFifoBlocking ex1_4.c
$ ./ReadFifoBlocking &
$ ./WriteFifoBlocking
$ ./WriteFifoBlocking &
$ ./ReadFifoBlocking


-----------------------------------------------------

Resultado: (por comando)
ReadFifoNonBlocking :
Abrindo FIFO
Começando a ler...
Fim da leitura

WriteFifoNonBlocking :
Abrindo FIFO
Erro ao abrir a FIFO minhaFifo

ReadFifoBlocking Background:
[1] 3807
Abrindo FIFO

WriteFifoBlocking Foreground:
Abrindo FIFO
Começando a escrever...
Começando a ler...
Fim da escrita
Melancia sem caroçoFim da leitura

WriteFifoBlocking Background:
[1] 3811
Abrindo FIFO

ReadFifoBlocking Foreground:
Abrindo FIFO
Começando a ler...
Começando a escrever...
Fim da escrita
Melancia sem caroçoFim da leitura

-----------------------------------------------------

Conclusão:
No caso da ReadFifoNonBlocking ela retorna imediatamente como se tivesse lido mesmo que essa FIFO não tenha sido aberta por outro processo.Quando a WriteFifoNonBlocking é executada ela procura por uma FIFO aberta para escrita mas como não encontra , a função open retorna -1 e o programa imprime o erro.Já no caso das funções que bloqueiam elas esperam a FIFO chamada por open ser criada por um outro processo.Por isso, quando executa a ReadFifoBlocking por exemplo ele não simplesmente executa tudo sem parar como a ReadFifoNonBlocking faz.Ele para assim que a FIFO é chamada no open.Quando WriteFifoBlocking é executada depois disso os 2 processos passam a operar sobre essa mesma FIFO e terminaram sua execução praticamente juntos.


-----------------------------------------------------

Questão 2) Abra duas seções de terminais
Na primeira, execute um programa que fica em loop lendo de uma FIFO para depois escrever na saída padrão (tela)
Na segunda, execute um programa que fica lendo da entrada padrão (teclado) e depois escreve na mesma FIFO

-----------------------------------------------------

Arquivos .c:
Loop lendo da FIFO:

#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#define FIFO "minhaFifo"

int main() {
	int fifo;
	char ch;

	if (access (FIFO, F_OK) == -1) {
		if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0) {
			fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
			return -1;
		}
	}
  printf ("\nAbrindo FIFO\n");
	if ((fifo = open (FIFO, O_RDONLY)) < 0) {
		fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
		return -2;
	}

	while (read (fifo, &ch, sizeof (ch)) > 0) {
    printf("\n");
		putchar (ch);
	}

	puts ("fim leitura");

	close (fifo);

	return 0;
}

Lendo da entrada padrão:

#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <sys/types.h>
#include <fcntl.h>
#include <string.h>
#define FIFO "minhaFifo"

int main() {
	int fifo;
	char ch;

	if (access (FIFO, F_OK) == -1) {
		if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0) {
			fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
			return -1;
		}
	}
  printf ("\nAbrindo FIFO\n");
	if ((fifo = open ("minhaFifo", O_WRONLY)) < 0) {
		  fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
		  return -2;
	}

	printf ("\nEscrevendo na FIFO o caracter do teclado\n");
	while (ch != '0') {
		scanf ("%c", &ch);
		write (fifo, &ch, 1);
	}

	close (fifo);

	return 0;
}



-----------------------------------------------------

Auxiliar .txt:
Não houve arquivo auxiliar nessa questão.

-----------------------------------------------------

Compilação e Execução:
$ gcc -Wall -o LoopRead ex2_1.c
$ gcc -Wall -o LoopWrite ex2_2.c
$ ./LoopRead
$ ./LoopWrite
Sendo que cada execução em uma janela diferente do terminal.

-----------------------------------------------------

Resultado:
Programa que lê do teclado e escreve na FIFO:

Abrindo FIFO

Escrevendo na FIFO o caracter do teclado
a
b
c
d

Programa que lê a FIFO:
Abrindo FIFO
a
b
c
d
-----------------------------------------------------

Conclusão:
Como a escrita e leitura da FIFO são blocking, o programa que lê a FIFO fica em loop eterno exibindo na tela sempre que algo novo é escrito na FIFO.Já o programa que escreve na FIFO também fica em loop eterno lendo do teclado os caracteres e escrevendo-os na FIFO.Quando duas janelas do terminal estão abertas pode-se visualizar bem essa escrita e leitura de uma FIFO blocking.


-----------------------------------------------------

Questão 3)Escreva um programa que primeiro cria uma FIFO e, em seguida, cria dois processos filho que escrevem cada um uma string na FIFO.
O pai aguarda os filhos acabarem de escrever e em seguida lê as strings da FIFO e às exibe na tela.
                        
-----------------------------------------------------

Arquivo .c:
#include <stdio.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/wait.h>
#define FIFO "minhaFifo"

int main() {
	int fifo = 0, fifo2 = 0,pid1,pid2;
	char mensagem[45];

	if (access (FIFO, F_OK) == -1) {
		if (mkfifo (FIFO, S_IRUSR | S_IWUSR) != 0) {
			fprintf (stderr, "Erro ao criar FIFO %s\n", FIFO);
			return -1;
		}
	}

	if ((pid1 = fork()) == 0) {
    //Filho 1
		if ((fifo = open (FIFO, O_WRONLY)) < 0) {
			fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
			return -2;
		}
		strcpy(mensagem, "Filho 1 escreveu na FIFO");
		write (fifo, mensagem, strlen (mensagem));

		return 0;
	}
	else {
		 if ((pid2 = fork()) == 0) {
       //Filho 2
			if ((fifo = open (FIFO, O_WRONLY)) < 0) {
				fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
				return -2;
			}
			strcpy(mensagem, "Filho 2 escreveu na FIFO");
			write (fifo, mensagem, strlen (mensagem));

			return 0;
		}
		// Pai
		else {
			if ((fifo2 = open (FIFO, O_RDONLY)) < 0) {
				fprintf (stderr, "Erro ao abrir a FIFO %s\n", FIFO);
				return -2;
			}
			int status;
			waitpid (pid1, &status, 0);
			waitpid (pid2, &status, 0);
			while (read (fifo2, mensagem, 100) > 0) {
				printf ("%s\n", mensagem);
			}
		}
	}


	close (fifo);

	return 0;
}


-----------------------------------------------------

Auxiliar .txt:
Não houve arquivo auxiliar nessa questão.

-----------------------------------------------------

Compilação e Execução:
$ gcc -Wall -o ex3 ex3.c
$ ./ex3
-----------------------------------------------------

Resultado:
Filho 1 escreveu na FIFO Filho 2 escreveu na FIFO
-----------------------------------------------------

Conclusão:
Caso a FIFO ainda não exista eu a crio.Em cada processo filho eu dou open pra escrita blocking e no pai para leitura blocking. Nos filhos eu escrevo as mensagens na FIFO e no pai eu espero os dois filhos terminarem e depois leio o que estiver na FIFO.
